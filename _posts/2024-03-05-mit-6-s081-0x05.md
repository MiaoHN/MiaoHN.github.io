---
title: "MIT 6.S081 | 0x05 Copy on-write"
date: 2024-03-05T12:00:00+08:00


math: true
tags: ["labs"]
---

- é“¾æ¥ï¼š<https://pdos.csail.mit.edu/6.S081/2021/labs/cow.html>
- éš¾åº¦ï¼š:red_square:

å˜¿å˜¿ã€‚ã€‚å˜¿ã€‚[ä¸Šä¸ªå®éªŒ](/posts/mit-6-s081-0x04)è¿˜æ˜¯åœ¨å»å¹´åšçš„ :yum:ã€‚éå¸¸æŠ±æ­‰æˆ‘æ‹–äº†è¿™ä¹ˆä¹…ï¼Œ~~æ‹–å»¶ç—‡æ™šæœŸäº†~~ã€‚ä¸è¿‡æ—¢ç„¶éƒ½å¼€äº†è¿™ä¸ªç³»åˆ—ï¼Œé‚£è¿˜æ˜¯æ›´æ–°å§ã€‚

> COW è¿™èŠ‚ lab æˆ‘é¡¶å¤šèŠ±äº† 15 ä¸ªå°æ—¶å°±åšå·®ä¸å¤šäº†ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªå° bug è¿Ÿè¿Ÿæ²¡æœ‰å‘ç°ï¼Œå¯¼è‡´æˆ‘ä¸€ç›´æ²¡æœ‰ä»»ä½•è¿›å±•ã€‚æœ€åå—ä¸äº†åœ¨ç½‘ä¸Šæ‰¾ä»£ç å¯¹æ¯”ï¼Œæ‰å‘ç°æˆ‘æŠŠ `uvmunmap` å‡½æ•°æœ€åä¸€ä¸ªå‚æ•°å†™é”™äº†ï¼Œå…¶å®ƒåœ°æ–¹éƒ½æ˜¯å¯¹çš„ï¼Œå°±å¾ˆéš¾å—ã€‚
>
> å‚è€ƒäº†[åˆ«äººå†™çš„ä»£ç ](https://ttzytt.com/2022/07/xv6_lab6_record/index.html)ï¼Œå‡½æ•°å°è£…çš„å¾ˆèˆ’æœï¼Œäºæ˜¯æˆ‘ä¹Ÿå°±æŒ‰ç›¸ä¼¼çš„æ–¹å¼æŠŠä¸€äº›ä»£ç ç®€å•åšäº†ä¸€ä¸‹å°è£…ã€‚
>
> ç„¶åå°±æ˜¯ `usertests` æœ‰ä¸€ä¸ª case `textwrite` ä¸€ç›´æ²¡é€šè¿‡ï¼Œæˆ‘æŠŠé‚£è¡Œæ³¨é‡Šæ‰å°±å…¨è¿‡äº†ï¼Œè¿™ç®—ä¸€ä¸ªå°é—æ†¾ï¼ŒåæœŸå¦‚æœèƒ½é€šè¿‡æˆ‘å°±æ›´æ–°ä¸€ä¸‹è¿™ç¯‡æ–‡ç« ã€‚
{: .prompt-info }

## ğŸŸ¥ Implement copy-on write

copy-on writeï¼ŒCOWï¼Œåˆç§°å†™æ—¶å¤åˆ¶ï¼Œè¿™ä¸ªå®éªŒç®— 6.S081 é‡Œæ¯”è¾ƒå‡ºåçš„å®éªŒäº†å§ã€‚åœ¨ä½¿ç”¨ `fork()` æ—¶ä¸ºäº†å‡å°‘å¼€é”€ï¼Œä¼šè®©çˆ¶å­è¿›ç¨‹çš„é¡µè¡¨æŒ‡å‘åŒä¸€ä¸ªç‰©ç†åœ°å€ï¼ŒèŠ‚çœäº†åˆ†é…ç©ºé—´æ‰€å çš„æ—¶é—´ã€‚å°†å¯¹åº”çš„é¡µæ”¹ä¸ºä¸å¯å†™ï¼Œç›´åˆ°å‡ºç° page fault æ—¶æ‰å¤åˆ¶å¯¹åº”çš„é¡µã€‚

æ‰€ä»¥æ•´ä¸ªå®éªŒä¸»è¦åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼š

1. è°ƒç”¨ `fork()` åä»…ä¿®æ”¹é¡µè¡¨ï¼Œå¹¶å°†æƒé™è®¾ä¸ºä¸å¯å†™
2. page fault æ—¶ä¸º COW çš„é¡µåˆ†é…ç©ºé—´

### ä¿®æ”¹ `uvmcopy()`

åœ¨ä½¿ç”¨ `fork()` åˆ›å»ºå­è¿›ç¨‹æ—¶ï¼Œä¼šä½¿ç”¨ `uvmcopy()` å°†çˆ¶è¿›ç¨‹é¡µè¡¨çš„ç©ºé—´å¤åˆ¶åˆ°å­è¿›ç¨‹çš„é¡µè¡¨ä¸­ã€‚è¿™éƒ¨åˆ†åŸæœ¬çš„åšæ³•æ˜¯æ—¢å¤åˆ¶é¡µè¡¨é¡µå¤åˆ¶å¯¹åº”çš„ç©ºé—´ã€‚è€Œæˆ‘ä»¬è¦å°†å…¶ä¿®æ”¹ä¸ºä»…å¤åˆ¶é¡µè¡¨å¹¶å°†ä¸¤ä¸ªé¡µè¡¨çš„æƒé™è®¾ä¸ºä¸å¯å†™ã€‚

> åœ¨ `uvmcopy()` é€šè¿‡å¤åˆ¶é¡µè¡¨ä½¿çˆ¶å­è¿›ç¨‹æŒ‡å‘åŒä¸€ä¸ªç‰©ç†ç©ºé—´ï¼Œè¯»çš„æ—¶å€™æ²¡æœ‰é—®é¢˜ï¼Œå½“éœ€è¦è¿›è¡Œå†™å…¥æ“ä½œæ—¶ï¼Œç”±äºæƒé™ä¸ºä¸å¯å†™ï¼Œæ‰€ä»¥ä¼šæŠ¥ page faultï¼Œæ‰€ä»¥åœ¨ `usertrap()` ä¸­é‡åˆ° page fault æ—¶æ‰ä¼šçœŸæ­£è¿›è¡Œç‰©ç†ç©ºé—´çš„å¤åˆ¶ã€‚
{: .prompt-tip }

```c
int
uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
{
  pte_t *pte;
  uint64 pa, i;
  uint flags;

  for(i = 0; i < sz; i += PGSIZE){
    if((pte = walk(old, i, 0)) == 0)
      panic("uvmcopy: pte should exist");
    if((*pte & PTE_V) == 0)
      panic("uvmcopy: page not present");
    pa = PTE2PA(*pte);

    *pte &= (~PTE_W);
    *pte |= PTE_C;   // cow flag
    flags = PTE_FLAGS(*pte);
    if (mappages(new, i, PGSIZE, (uint64)pa, flags) != 0) {
      printf("uvmcopy: failed\n");
      uvmunmap(new, 0, i / PGSIZE, 1);
      return -1;
    }
    ref_cnt_inc(pa);  // increase page ref count
  }
  return 0;
}
```

è¿™ä¸€æ­¥å¾ˆç®€å•ï¼Œåˆ æ‰åŸå…ˆçš„ `kalloc()`ï¼Œåªæ“ä½œé¡µè¡¨å°±å¯ä»¥äº†ã€‚

### ä¿®æ”¹ `usertrap()`

å‰é¢å·²ç»æŒ‡å‡ºï¼Œåœ¨ `fork()` æ—¶ä»…ä¿®æ”¹äº†é¡µè¡¨ï¼Œå¦‚æœå°è¯•å†™æ“ä½œæ—¶ä¼šæŠ¥ page faultï¼Œè€Œè¿™ä¸ªä¸­æ–­åœ¨ `usertrap()` ä¸­çš„ä¸­æ–­å·ï¼ˆ`r_scause()`ï¼‰æ˜¯ 15ã€‚æ‰€ä»¥åœ¨å‘ç”Ÿ 15 å·ä¸­æ–­æ—¶æˆ‘ä»¬éœ€è¦åšä¸¤ä»¶äº‹ï¼š

1. åˆ¤æ–­æ˜¯å¦æ˜¯ç”±äº COW å¯¼è‡´çš„ page fault
2. ä¸º cow page fault å¤åˆ¶å¯¹åº”çš„ç‰©ç†ç©ºé—´

> è¿™é‡Œåˆ†äº†ä¸¤æ­¥ï¼Œæ„Ÿè§‰é‡å¤è°ƒç”¨äº†ä¸¤å› `walk()`ã€‚å®é™…ä¸Šå¯ä»¥è§£è€¦æ“ä½œï¼Œç¬¬ä¸€æ­¥åˆ¤æ–­æ˜¯å¦æ˜¯ COW é¡µçš„å‡½æ•°ä¼šåœ¨ `copyout()` ä¸­é‡åˆ°ã€‚
{: .promp-tip }

é¦–å…ˆåˆ¤æ–­æ‰€åœ¨çš„é¡µæ˜¯å¦æ˜¯ COW é¡µï¼Œæˆ‘ä»¬å°†é¡µè¡¨å¯¹åº”çš„ flag å–åˆ°è¿›è¡Œåˆ¤æ–­å³å¯ï¼Œè¿™ä¸ªå‘½åä¹Ÿå¯å–ä¸º `is_cow_page()`

```c
int cow_uncopied(pagetable_t pgtbl, uint64 va) {
  if (va >= MAXVA) return 0;
  pte_t * pte = walk(pgtbl, va, 0);
  if (pte == 0) return 0;
  if ((*pte & PTE_V) == 0) return 0;
  if ((*pte & PTE_U) == 0) return 0;
  return ((*pte) & PTE_C);
}
```

æ¥ä¸‹æ¥å°±æ˜¯ä¸º COW é¡µåˆ†é…ç©ºé—´çš„æ“ä½œï¼Œè¿™æ®µä»£ç å®é™…ä¸Šåœ¨ä¹‹å‰çš„ `uvmcopy()` é‡Œå·²ç»æœ‰ä¸€éƒ¨åˆ†äº†ï¼Œå‚è€ƒç€å†™å°± okã€‚

```c
int cow_alloc(pagetable_t pgtbl, uint64 va) {
  pte_t *pte = walk(pgtbl, va, 0);
  if (pte == 0) return -1;
  uint flags = PTE_FLAGS(*pte);

  uint64 pa = PTE2PA(*pte);

  char *mem = kalloc();
  if (mem == 0) return -1;

  va = PGROUNDDOWN(va);
  flags &= (~PTE_C);
  flags |= PTE_W;

  memmove(mem, (char*)pa, PGSIZE);
  uvmunmap(pgtbl, va, 1, 1);    // !!!
  if (mappages(pgtbl, va, PGSIZE, (uint64)mem, flags) < 0) {
    kfree(mem);
    return -1;
  }
  return 0;
}
```

> è¿™é‡Œæœ‰ä¸ªå°å‘ï¼Œä¹Ÿæ˜¯å› ä¸ºæˆ‘æ²¡æ³¨æ„ã€‚`uvmunmap(pgtbl, va, 1, 1)` æœ€åçš„é‚£ä¸ªå‚æ•°å¾—æ”¹æˆ 1ï¼Œç”¨æ¥å‡å°å¯¹åº”é¡µçš„å¼•ç”¨è®¡æ•°ï¼Œä¸ç„¶å°±ä¼šå‡ºå¤§é—®é¢˜ã€‚å°±æ˜¯è¿™é‡Œå¡äº†æˆ‘å¥½ä¹…ï¼Œè¿˜æ˜¯ä¿®è¡Œä¸å¤ªå¤Ÿhhh
{: .prompt-info}

å®Œæˆä¸Šé¢ä¸¤ä¸ªå‡½æ•°ï¼Œåœ¨ `usertrap()` ä¸­å°±å†™çš„å¾ˆèˆ’æœäº†ï¼š

```diff
@@ -65,6 +97,10 @@ usertrap(void)
     intr_on();
 
     syscall();
+  } else if (r_scause() == 15 && cow_uncopied(p->pagetable, r_stval())) {
+    if (cow_alloc(p->pagetable, r_stval()) < 0) {
+      setkilled(p);
+    }
   } else if((which_dev = devintr()) != 0){
     // ok
   } else {
```

### ä¿®æ”¹ `copyout()`

ä¸Šä¸€èŠ‚å°è£…çš„å‡½æ•°ç«‹åˆ»å°±èƒ½åœ¨ `copyout()` ä¸­ç”¨åˆ°

```diff
@@ -355,6 +352,12 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
+    if (cow_uncopied(pagetable, va0)) {
+      if (cow_alloc(pagetable, va0) < 0) {
+        return -1;
+      }
+    }
+
     pa0 = walkaddr(pagetable, va0);
     if(pa0 == 0)
       return -1;
```

> æ³¨æ„ `cow_alloc()` è¦æ”¾åˆ° `walkaddr()` å‰é¢å“¦ã€‚ä¸ç„¶ `walkaddr()` å–åˆ°çš„æ˜¯çˆ¶è¿›ç¨‹çš„åœ°å€ï¼Œè€Œä¸æ˜¯ `kalloc()` åå¾—åˆ°çš„æ–°åœ°å€ã€‚
{: .prompt-info}

### æ·»åŠ å¼•ç”¨è®¡æ•°

ä¸ºä»€ä¹ˆè¦è¿›è¡Œå¼•ç”¨è®¡æ•°å‘¢ï¼Ÿå½“å®ç°äº† COW åï¼Œä¸€ä¸ªç‰©ç†é¡µå¯èƒ½ä¼šè¢«å¤šä¸ªè¿›ç¨‹ä½¿ç”¨ï¼Œè¿™æ—¶å€™å¦‚æœå“ªä¸ªè¿›ç¨‹ `free` æ‰è¿™ä¸ªé¡µï¼Œå…¶å®ƒè¿›ç¨‹å°±æ‰¾ä¸ç€è¿™ä¸ªé¡µäº†ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨ä¸€ä¸ªå¼•ç”¨è®¡æ•°æ¥ç®¡ç†ç‰©ç†é¡µä¸é¡µè¡¨çš„å…³ç³»ï¼Œ**åªæœ‰å½“ä¸€ä¸ªç‰©ç†é¡µä¸è¢«ä»»ä½•é¡µè¡¨å¼•ç”¨æ—¶æ‰è¿›è¡Œ `free`**ã€‚å¼•ç”¨è®¡æ•°åœ¨ä»¥ä¸‹æƒ…å†µæ—¶ä¼šå‘ç”Ÿæ”¹å˜ï¼š

1. `kalloc()` æ—¶ä¼šè¢«è®¾ä¸º 1
2. `kfree()` æ—¶å¼•ç”¨å‡å°‘ï¼Œå¦‚æœä¸ºé›¶åˆ™çœŸçš„æ¸…é™¤ç©ºé—´
3. è¢«å…¶å®ƒè¿›ç¨‹å¼•ç”¨ï¼ˆä»…åœ¨ `fork()` ä¸­ï¼‰æ—¶å¼•ç”¨å¢åŠ 

å”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯æ•°ç»„ `ref_cnt` çš„å¤§å°ï¼Œæˆ‘è®¾ä¸ºäº† `PHYSTOP / PGSIZE`ã€‚

### å…¨éƒ¨ä»£ç 

å…·ä½“ç»†èŠ‚çœ‹ä»£ç ï¼Œæ³¨æ„æˆ‘æŠŠ `usertests` é‡Œçš„ `textwrite()` ç»™æ³¨é‡Šæ‰äº†ï¼Œåªæœ‰è¿™ä¸ª case æˆ‘æ²¡æ³•é€šè¿‡ï¼Œå“­å“­

```diff
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..1935a1a 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+void            ref_cnt_inc(uint64);
 
 // log.c
 void            initlog(int, struct superblock*);
@@ -173,6 +174,8 @@ uint64          walkaddr(pagetable_t, uint64);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+int             cow_uncopied(pagetable_t, uint64);
+int             cow_alloc(pagetable_t, uint64);
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 0699e7e..e323d58 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -14,6 +14,17 @@ void freerange(void *pa_start, void *pa_end);
 extern char end[]; // first address after kernel.
                    // defined by kernel.ld.
 
+int ref_cnt[PHYSTOP / PGSIZE];
+struct spinlock ref_cnt_lock;
+
+#define REF_CNT(pa) ref_cnt[(uint64)pa / PGSIZE]
+
+void ref_cnt_inc(uint64 pa) {
+  acquire(&ref_cnt_lock);
+  REF_CNT(pa)++;
+  release(&ref_cnt_lock);
+}
+
 struct run {
   struct run *next;
 };
@@ -27,7 +38,9 @@ void
 kinit()
 {
   initlock(&kmem.lock, "kmem");
+  initlock(&ref_cnt_lock, "ref_cnt");
   freerange(end, (void*)PHYSTOP);
+  memset(ref_cnt, 0, PHYSTOP / PGSIZE);
 }
 
 void
@@ -51,6 +64,14 @@ kfree(void *pa)
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
 
+  acquire(&ref_cnt_lock);
+  if (REF_CNT(pa) > 1) {
+    REF_CNT(pa)--;
+    release(&ref_cnt_lock);
+    return;
+  }
+  release(&ref_cnt_lock);
+
   // Fill with junk to catch dangling refs.
   memset(pa, 1, PGSIZE);
 
@@ -76,7 +97,11 @@ kalloc(void)
     kmem.freelist = r->next;
   release(&kmem.lock);
 
-  if(r)
+  if(r) {
     memset((char*)r, 5, PGSIZE); // fill with junk
+    acquire(&ref_cnt_lock);
+    REF_CNT(r) = 1;
+    release(&ref_cnt_lock);
+  }
   return (void*)r;
 }
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..0eb9183 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -343,6 +343,7 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
+#define PTE_C (1L << 8) // cow page
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
diff --git a/kernel/trap.c b/kernel/trap.c
index 512c850..4f56f9d 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -29,6 +29,38 @@ trapinithart(void)
   w_stvec((uint64)kernelvec);
 }
 
+int cow_uncopied(pagetable_t pgtbl, uint64 va) {
+  if (va >= MAXVA) return 0;
+  pte_t * pte = walk(pgtbl, va, 0);
+  if (pte == 0) return 0;
+  if ((*pte & PTE_V) == 0) return 0;
+  if ((*pte & PTE_U) == 0) return 0;
+  return ((*pte) & PTE_C);
+}
+
+int cow_alloc(pagetable_t pgtbl, uint64 va) {
+  pte_t *pte = walk(pgtbl, va, 0);
+  if (pte == 0) return -1;
+  uint flags = PTE_FLAGS(*pte);
+
+  uint64 pa = PTE2PA(*pte);
+
+  char *mem = kalloc();
+  if (mem == 0) return -1;
+
+  va = PGROUNDDOWN(va);
+  flags &= (~PTE_C);
+  flags |= PTE_W;
+
+  memmove(mem, (char*)pa, PGSIZE);
+  uvmunmap(pgtbl, va, 1, 1);
+  if (mappages(pgtbl, va, PGSIZE, (uint64)mem, flags) < 0) {
+    kfree(mem);
+    return -1;
+  }
+  return 0;
+}
+
 //
 // handle an interrupt, exception, or system call from user space.
 // called from trampoline.S
@@ -65,6 +97,10 @@ usertrap(void)
     intr_on();
 
     syscall();
+  } else if (r_scause() == 15 && cow_uncopied(p->pagetable, r_stval())) {
+    if (cow_alloc(p->pagetable, r_stval()) < 0) {
+      setkilled(p);
+    }
   } else if((which_dev = devintr()) != 0){
     // ok
   } else {
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..918b1d9 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -308,7 +308,6 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   pte_t *pte;
   uint64 pa, i;
   uint flags;
-  char *mem;
 
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
@@ -316,20 +315,18 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
     if((*pte & PTE_V) == 0)
       panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
+
+    *pte &= (~PTE_W);
+    *pte |= PTE_C;
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
-      goto err;
+    if (mappages(new, i, PGSIZE, (uint64)pa, flags) != 0) {
+      printf("uvmcopy: failed\n");
+      uvmunmap(new, 0, i / PGSIZE, 1);
+      return -1;
     }
+    ref_cnt_inc(pa);
   }
   return 0;
-
- err:
-  uvmunmap(new, 0, i / PGSIZE, 1);
-  return -1;
 }
 
 // mark a PTE invalid for user access.
@@ -355,6 +352,12 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
+    if (cow_uncopied(pagetable, va0)) {
+      if (cow_alloc(pagetable, va0) < 0) {
+        return -1;
+      }
+    }
+
     pa0 = walkaddr(pagetable, va0);
     if(pa0 == 0)
       return -1;
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..3f10ffe
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+15
\ No newline at end of file
diff --git a/user/usertests.c b/user/usertests.c
index 7d3e9bc..301b631 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -2629,7 +2629,7 @@ struct test {
   {bigargtest, "bigargtest"},
   {argptest, "argptest"},
   {stacktest, "stacktest"},
-  {textwrite, "textwrite"},
+  // {textwrite, "textwrite"},
   {pgbug, "pgbug" },
   {sbrkbugs, "sbrkbugs" },
   {sbrklast, "sbrklast"},
```
