---
title: "MIT 6.S081 | 0x04 Traps"
date: 2023-12-30T12:00:00+08:00
categories: ["Courses & Labs", "MIT 6.S081"]


math: true
tags: ["labs"]
---

- é“¾æ¥ï¼š<https://pdos.csail.mit.edu/6.S081/2021/labs/traps.html>
- éš¾åº¦ï¼š :green_square::blue_square::red_square:

> Before you start coding, read Chapter 4 of the [xv6 book](https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf), and related source files:
>
> - `kernel/trampoline.S`: the assembly involved in changing from user space to kernel space and back
> - `kernel/trap.c`: code handling all interrupts
{: .prompt-tip }

## :green_square: RISC-V assembly

è¿™é“é¢˜è®©æˆ‘ä»¬é€šè¿‡é˜…è¯»ä¸€ä¸ªæ–‡ä»¶ `user/call.c` çš„ `asm` ä»£ç æ¥å­¦ä¹  RISC-V æ±‡ç¼–çš„ä¸€äº›åŸºç¡€çŸ¥è¯†

```c
#include "kernel/param.h"
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int g(int x) {
  return x+3;
}

int f(int x) {
  return g(x);
}

void main(void) {
  printf("%d %d\n", f(8)+1, 13);
  exit(0);
}
```

è¿™ä¸ªæ–‡ä»¶å¾ˆç®€å•ï¼Œ`main` ä½¿ç”¨ `printf` æ‰“å°ä¸¤ä¸ªæ•°å­—ï¼Œå¹¶åœ¨å…¶ä¸­é€šè¿‡ `f` è°ƒç”¨ `g`ã€‚ä¸‹é¢å°±æ¥çœ‹çœ‹å®éªŒæäº†å“ªäº›é—®é¢˜å§

> Which registers contain arguments to functions? For example, which register holds 13 in main's call to `printf`?

ç›´æ¥çœ‹ä»£ç ï¼š

```
000000000000001c <main>:

void main(void) {
  1c: 1141                 addi sp,sp,-16
  1e: e406                 sd ra,8(sp)
  20: e022                 sd s0,0(sp)
  22: 0800                 addi s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24: 4635                 li a2,13
  26: 45b1                 li a1,12
  28: 00000517             auipc a0,0x0
  2c: 7b850513             addi a0,a0,1976 # 7e0 <malloc+0xe6>
  30: 00000097             auipc ra,0x0
  34: 612080e7             jalr 1554(ra) # 642 <printf>
  exit(0);
  38: 4501                 li a0,0
  3a: 00000097             auipc ra,0x0
  3e: 28e080e7             jalr 654(ra) # 2c8 <exit>
```

åœ¨ 24 å’Œ 26 è¿™ä¸¤è¡Œåˆ†åˆ«å‘ `a2` å’Œ `a1` ä¸¤ä¸ªå¯„å­˜å™¨å­˜äº† 13ã€12 è¿™ä¸¤ä¸ªå€¼ã€‚æ‰€ä»¥å¯ä»¥å›ç­”è¿™ä¸ªé—®é¢˜ï¼Œå‡½æ•°çš„å¯„å­˜å™¨å­˜åœ¨ `a1`~`a7` è¿™äº›å¯„å­˜å™¨ä¸­ï¼ˆæŸ¥æŸ¥ RISC-V å¯„å­˜å™¨ä¹Ÿèƒ½çŸ¥é“ï¼‰

> Where is the call to function `f` in the assembly code for `main`? Where is the call to `g`? (Hint: the compiler may inline functions.)

è¿˜æ˜¯ä¸Šé¢é‚£æ®µä»£ç ï¼Œ`a1` å’Œ `a2` å­˜äº†ä¸¤ä¸ªç«‹å³æ•°ï¼Œè¿™ä¸ª 12 å…¶å®å°±æ˜¯ `f(8)+1` çš„ç»“æœã€‚æ‰€ä»¥è¯´ç¼–è¯‘å™¨åœ¨ç¼–è¯‘çš„è¿‡ç¨‹ä¸­ç›´æ¥å°† `f` å’Œ `g` çš„è°ƒç”¨è¿›è¡Œå†…è”ï¼Œç›´æ¥ç”¨å®ƒä»¬çš„ç»“æœè¿›è¡Œç¼–è¯‘äº†

> At what address is the function `printf` located?

```
0000000000000642 <printf>:
```

æ‰€ä»¥ `printf` è¿™ä¸ªå‡½æ•°çš„åœ°å€ä½äº 0x642ã€‚è¿™ä¸ªé—®é¢˜ä¸€å‡ºæ¥ï¼Œå°±ä¼šå¾ˆè‡ªç„¶åœ°æƒ³åˆ°ä¸‹é¢çš„é—®é¢˜ï¼š

> What value is in the register `ra` just after the `jalr` to `printf` in `main`?

åœ¨ `main` ä¸­æœ‰ä¸€å¥ `jalr 1554(ra)`ï¼Œè¿™åº”è¯¥æ˜¯åœ¨ `ra` çš„åŸºç¡€ä¸ŠåŠ  1554ï¼Œè€Œä¸”è¿™æ˜¯ä¸€ä¸ªåè¿›åˆ¶ç«‹å³æ•°ï¼Œé‚£ä¹ˆ 0x642 å‡å»è¿™ä¸ªç«‹å³æ•°å¾—åˆ°çš„ç»“æœæ˜¯ 48ï¼Œè½¬æ¢ä¸ºåå…­è¿›åˆ¶å°±æ˜¯ 0x30ï¼Œè¿™æ­£å¥½æ˜¯ `jalr` è·³è½¬çš„ä¸Šä¸€å¥åœ°å€

> æˆ‘è¿˜æŸ¥äº†ä¸€ä¸‹ `auipc ra, 0x0` çš„å«ä¹‰ï¼š
>
> è¿™æ˜¯ä¸€ä¸ª RISC-V æŒ‡ä»¤ï¼Œç”¨äºå°†ä¸€ä¸ª 20 ä½çš„ç«‹å³æ•°ï¼ˆåç§»é‡ï¼‰åŠ åˆ°å½“å‰æŒ‡ä»¤çš„åœ°å€çš„é«˜ 20 ä½ä¸Šï¼Œç»“æœå­˜å‚¨åœ¨ç›®æ ‡å¯„å­˜å™¨ `ra` ä¸­
>
> å…·ä½“æ¥è¯´ï¼Œ`auipc` æŒ‡ä»¤å°†å½“å‰æŒ‡ä»¤çš„åœ°å€çš„é«˜ 20 ä½ï¼ˆå³ `PC[31:12]`ï¼‰ä¸ä¸€ä¸ª 20 ä½çš„ç«‹å³æ•°ç›¸åŠ ï¼Œå¾—åˆ°ä¸€ä¸ª 32 ä½çš„åœ°å€ï¼Œç„¶åå°†è¿™ä¸ªåœ°å€å­˜å‚¨åœ¨ç›®æ ‡å¯„å­˜å™¨ `ra` ä¸­ã€‚è¿™ä¸ªæŒ‡ä»¤é€šå¸¸ç”¨äºè®¡ç®—å…¨å±€åœ°å€ï¼Œä¾‹å¦‚ç”¨äºåŠ è½½å…¨å±€å˜é‡çš„åœ°å€
>
> **ä¾‹å¦‚ï¼Œå¦‚æœå½“å‰æŒ‡ä»¤çš„åœ°å€æ˜¯ 0x1000ï¼Œé‚£ä¹ˆæ‰§è¡Œ `auipc ra, 0x0` æŒ‡ä»¤åï¼Œç›®æ ‡å¯„å­˜å™¨ `ra` å°†è¢«è®¾ç½®ä¸º 0x1000**
{: .prompt-tip }

> Run the following code.
>
> ```c
> unsigned int i = 0x00646c72;
> printf("H%x Wo%s", 57616, &i);
> ```
>
> What is the output?
>
> The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

è¿™ä¸ªé—®é¢˜è€ƒå¯Ÿæˆ‘ä»¬å¯¹å¤§ç«¯å°ç«¯çš„ç†è§£ï¼Œä¸‹é¢å…ˆæ¥è¿›è¡Œä¸€ä¸ªåˆ†æã€‚é¦–å…ˆæ˜¯ `"H%x"`ï¼Œè¿™ä¸ª `%x` æ‰“å°çš„æ˜¯ 57616 çš„ 16 è¿›åˆ¶å€¼ï¼Œè·Ÿå¤§å°ç«¯æ²¡å…³ç³»ï¼Œæ‰€ä»¥æ‰“å°çš„ç¬¬ä¸€ä¸ªå€¼å¿…å®šæ˜¯ `HE110`ã€‚ç„¶åæ˜¯è¿™ä¸ª `"Wo%s"`ï¼Œå°†ä¸€ä¸ªæ— ç¬¦å·æ•´æ•°è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå› ä¸º RISC-V æ˜¯å°ç«¯å­˜å‚¨ï¼Œæ‰€ä»¥ä½åœ°å€åœ¨å‰ï¼Œé«˜åœ°å€åœ¨åï¼Œæ‰€ä»¥æ‰“å°çš„å­—ç¬¦åº”è¯¥åˆ†åˆ«ä¸º `72`ã€`6c`ã€`64` ä»¥åŠ `00`ï¼ˆå­—ç¬¦ä¸²ç»“æŸï¼‰ï¼ŒASCII è½¬ç åæ‰“å°å¾—åˆ°çš„æ˜¯ `rld`ã€‚ç°åœ¨å¯ä»¥å¯¹è¿™ä¸ªé—®é¢˜è¿›è¡Œä¸€ä¸ªè§£ç­”ï¼š

1. å› ä¸º RISC-V æ˜¯å°ç«¯å­˜å‚¨ï¼Œæ‰€ä»¥å…¨éƒ¨çš„è¾“å‡ºä¸ºï¼š`HE110 World`
2. å¦‚æœæ˜¯å¤§ç«¯å­˜å‚¨ï¼Œå› ä¸º `57616` ç›´æ¥æ‰“å°å€¼ï¼Œæ‰€ä»¥ä¸éœ€è¦æ”¹å˜ï¼›è€Œ `i` éœ€è¦æ”¹å˜ï¼Œåº”æ”¹ä¸º `0x726c6400`

> In the following code, what is going to be printed after `y=`? (note: the answer is not a specific value.) Why does this happen?
>
> ```c
> printf("x=%d y=%d", 3);
> ```

`y=` åçš„æ•°å­—ä¸ç¡®å®šï¼Œå…¶æ•°å€¼å–å†³äºè°ƒç”¨ `printf` æ—¶ç¬¬äºŒä¸ªå¯„å­˜å™¨ `a2` ä¸Šçš„å€¼ã€‚å‘ç”Ÿè¿™ç§æƒ…å†µçš„åŸå› æ˜¯ `printf` å†…æœ‰ä¸¤ä¸ªå˜é‡éœ€è¦è¾“å‡ºï¼Œä½†åœ¨åé¢çš„åˆ—è¡¨ä¸­åªç»™äº†ä¸€ä¸ªå€¼ï¼Œç¬¬äºŒä¸ªå€¼æœªç»™å®šï¼Œå¯¼è‡´äº†è¾“å‡ºç»“æœçš„ä¸ç¡®å®š

## :blue_square: Backtrace

> Implement a `backtrace()` function in `kernel/printf.c`. Insert a call to this function in `sys_sleep`, and then run `bttest`, which calls `sys_sleep`. Your output should be as follows:
>
> ```bash
> backtrace:
> 0x0000000080002cda
> 0x0000000080002bb6
> 0x0000000080002898
> ```
>
> After `bttest` exit qemu. In your terminal: the addresses may be slightly different but if you run `addr2line -e kernel/kernel` (or `riscv64-unknown-elf-addr2line -e kernel/kernel`) and cut-and-paste the above addresses as follows:
>
> ```bash
> $ addr2line -e kernel/kernel
> 0x0000000080002de2
> 0x0000000080002f4a
> 0x0000000080002bfc
> Ctrl-D
> ```
>
>You should see something like this:
>
> ```txt
> kernel/sysproc.c:74
> kernel/syscall.c:224
> kernel/trap.c:85
> ```

### åˆ†æ

å®ç°ä¸€ä¸ª `backtrace()` æ–¹ä¾¿è°ƒè¯•ã€‚GCC ç¼–è¯‘å™¨å°†å½“å‰è°ƒç”¨å‡½æ•°çš„ frame pointer å­˜åˆ°å¯„å­˜å™¨ `s0` ä¸­ï¼Œä¸‹å›¾æ˜¯å‡½æ•°æ ˆçš„ç»“æ„ï¼Œè¿”å›åœ°å€å­˜åˆ° `fp - 8` çš„ä½ç½®ï¼Œ`fp - 16` æ˜¯ä¸Šä¸€ä¸ª `fp` æŒ‡é’ˆçš„ä½ç½®

![frame pointer](https://cdn.jsdelivr.net/gh/MiaoHN/image-host@master/images/20240608103905.png)

### ä»£ç 

```diff
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..4b82fc2 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -80,6 +80,7 @@ int             pipewrite(struct pipe*, uint64, int);
 void            printf(char*, ...);
 void            panic(char*) __attribute__((noreturn));
 void            printfinit(void);
+void            backtrace(void);
 
 // proc.c
 int             cpuid(void);
diff --git a/kernel/printf.c b/kernel/printf.c
index 1a50203..1fffaa4 100644
--- a/kernel/printf.c
+++ b/kernel/printf.c
@@ -133,3 +133,19 @@ printfinit(void)
   initlock(&pr.lock, "pr");
   pr.locking = 1;
 }
+
+void
+backtrace(void)
+{
+  uint64 fp, up, ra;
+
+  fp = r_fp();
+  up = PGROUNDUP(fp);
+
+  printf("backtrace:\n");
+  while (fp != up) {
+    ra = *(uint64*)(fp - 8);
+    printf("%p\n", ra);
+    fp = *(uint64*)(fp - 16);
+  }
+}
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..85a08cc 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -319,6 +319,14 @@ r_ra()
   return x;
 }
 
+static inline uint64
+r_fp()
+{
+  uint64 x;
+  asm volatile("mv %0, s0" : "=r" (x) );
+  return x;
+}
+
 // flush the TLB.
 static inline void
 sfence_vma()
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..4ef466f 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -51,6 +51,7 @@ sys_sbrk(void)
 uint64
 sys_sleep(void)
 {
+  backtrace();
   int n;
   uint ticks0;
```

## ğŸŸ¥ Alarm

> In this exercise you'll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you'll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.

### åˆ†æ

è¿™ä¸ªä»»åŠ¡è¦æˆ‘ä»¬å®ç° `sigalarm` å’Œ `sigreturn`ã€‚å‰è€…æ¯éš”è‹¥å¹²ä¸ª `ticks` æ‰§è¡Œä¸€ä¸ª `handler` å‡½æ•°ï¼Œåè€…ç»“æŸè¿™ä¸ª `sigalarm` åˆ†é…çš„ä»»åŠ¡ã€‚åœ¨ RISC-V ä¸­ï¼Œç”¨æˆ·ç©ºé—´ä¸­çš„ `pc` å­˜åœ¨ `p->trapframe->epc` ä¸­ï¼Œæˆ‘ä»¬åœ¨å‘ç”Ÿæ—¶é’Ÿä¸­æ–­æ—¶æ›´æ–° `alarm_tick_count`ï¼Œå¦‚æœè¾¾åˆ°ç›¸åº”çš„ ticks æ•°åˆ™æ‰§è¡Œ `alarm_handler`ï¼ˆå³ `p->trapframe->epc = p->alarm_handler`ï¼‰

å¤§ä½“çš„æ€è·¯ä¸æ˜¯å¾ˆå¤æ‚ï¼Œæœ‰ä¸€äº›ç»†èŠ‚éœ€è¦æ³¨æ„ï¼š

1. åœ¨æ‰§è¡Œ `handler` å‡½æ•°ä¹‹å‰è¦ä¿æŒä¸€äº›å¿…è¦çš„å¯„å­˜å™¨ï¼Œæˆ‘è¿™é‡Œæ˜¯ç›´æ¥å°† `trapframe` è¿›è¡Œå¤åˆ¶ã€‚åœ¨ `sigreturn` çš„æ—¶å€™è¿˜éœ€è¦å°†è¿™äº›å¯„å­˜å™¨çš„å€¼è¿›è¡Œå¤åŸ
2. ä¸ºäº†é˜²æ­¢é‡å¤å¯¹ `handler` è¿›è¡Œèµ‹å€¼å¹¶è°ƒç”¨ï¼Œæˆ‘åœ¨ `proc` ä¸­è®¾ç½®äº†ä¸€ä¸ªå¼€å…³å˜é‡ `alarm_running`ï¼Œåœ¨æ‰§è¡Œ `handler` åæ— æ³•å†æ¬¡å¯¹ `handler` å¤åˆ¶ï¼Œç›´åˆ°è°ƒç”¨ `sigreturn`

### ä»£ç 

```diff
diff --git a/Makefile b/Makefile
index ded5bc2..d89ddfe 100644
--- a/Makefile
+++ b/Makefile
@@ -199,6 +199,7 @@ endif
 
 ifeq ($(LAB),traps)
 UPROGS += \
+ $U/_alarmtest\
  $U/_call\
  $U/_bttest
 endif
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..5586691 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -132,6 +132,12 @@ found:
     return 0;
   }
 
+  if((p->alarm_trapframe = (struct trapframe *)kalloc()) == 0){
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
   if(p->pagetable == 0){
@@ -146,6 +152,11 @@ found:
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
+  p->alarm_handler = 0;
+  p->alarm_intervals = 0;
+  p->alarm_tick_count = 0;
+  p->alarm_running = 0;
+
   return p;
 }
 
@@ -157,6 +168,8 @@ freeproc(struct proc *p)
 {
   if(p->trapframe)
     kfree((void*)p->trapframe);
+  if(p->alarm_trapframe)
+    kfree((void*)p->alarm_trapframe);
   p->trapframe = 0;
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..77339dc 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -104,4 +104,10 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  
+  void (*alarm_handler)();
+  struct trapframe *alarm_trapframe;
+  int alarm_tick_count;
+  int alarm_intervals;
+  int alarm_running;
 };
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..cf8a2fc 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,8 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_sigalarm(void);
+extern uint64 sys_sigreturn(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +128,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_sigalarm]  sys_sigalarm,
+[SYS_sigreturn] sys_sigreturn,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..382d781 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_sigalarm  22
+#define SYS_sigreturn 23
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 4ef466f..583cf80 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -92,3 +92,27 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_sigalarm(void)
+{
+  struct proc* p = myproc();
+
+  argint(0, &p->alarm_intervals);
+  argaddr(1, (uint64*)&p->alarm_handler);
+
+  p->alarm_tick_count = 0;
+
+  return 0;
+}
+
+uint64
+sys_sigreturn(void)
+{
+  struct proc* p = myproc();
+
+  *p->trapframe = *p->alarm_trapframe;
+  p->alarm_running = 0;
+
+  return p->trapframe->a0;
+}
diff --git a/kernel/trap.c b/kernel/trap.c
index 512c850..94af5c0 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -67,6 +67,17 @@ usertrap(void)
     syscall();
   } else if((which_dev = devintr()) != 0){
     // ok
+    if(which_dev == 2) {
+      if (p->alarm_intervals > 0) {
+        p->alarm_tick_count++;
+        if (p->alarm_tick_count == p->alarm_intervals && p->alarm_running == 0) {
+          *p->alarm_trapframe = *p->trapframe;
+          p->trapframe->epc = (uint64)p->alarm_handler;
+          p->alarm_tick_count = 0;
+          p->alarm_running = 1;
+        }
+      }
+    }
   } else {
     printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
diff --git a/user/user.h b/user/user.h
index 4d398d5..9426153 100644
--- a/user/user.h
+++ b/user/user.h
@@ -22,6 +22,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int sigalarm(int ticks, void (*handler)());
+int sigreturn(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..fa548b0 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("sigalarm");
+entry("sigreturn");
```
